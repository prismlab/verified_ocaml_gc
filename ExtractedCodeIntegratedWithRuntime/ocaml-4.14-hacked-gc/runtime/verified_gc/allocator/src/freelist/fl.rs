use crate::{
    colors::BLUE,
    utils::get_next,
    value::{Value, VAL_NULL},
    word::Wsize,
};

use super::globals::NfGlobals;

#[derive(Debug)]
pub struct FreeList<'a> {
    globals: &'a mut NfGlobals,
}

impl FreeList<'_> {
    pub fn nf_iter(&mut self) -> NfIter<'_> {
        // NfIter::new(self)
        let prev = self.globals.nf_prev;
        NfIter {
            globals: self.globals,
            prev,
            visited_start_once: false,
        }
    }
    pub fn new(g: &mut NfGlobals) -> FreeList {
        FreeList { globals: g }
    }

    pub fn find_next(&mut self, wo_sz: Wsize) -> Option<NfIterVal> {
        self.nf_iter()
            .find(|e| e.get_cur().get_header().get_wosize().get_val() >= wo_sz.get_val())
    }
}

pub struct NfIter<'a> {
    globals: &'a mut NfGlobals,
    prev: Value,
    visited_start_once: bool,
}

impl NfIter<'_> {
    fn get_globals(&self) -> &NfGlobals {
        self.globals
    }
    fn get_globals_mut(&mut self) -> &mut NfGlobals {
        self.globals
    }
}

#[derive(Debug)]
pub struct NfIterVal {
    prev: Value,
    cur: Value,
    prev_is_sentinel: bool,
}
impl NfIterVal {
    #[inline(always)]
    pub fn get_cur(&self) -> Value {
        self.cur
    }
    #[inline(always)]
    pub fn get_prev(&self) -> Value {
        if !self.prev_is_sentinel {
            return self.prev;
        }
        VAL_NULL
    }

    // This is not public, can only be used within this module
    // We would want to call this when we're changing the next value for prev that is generated by
    // iterator.
    // This is used in NfAllocator::nf_allocate_block ,NfAllocator::nf_add_block and
    // NfAllocator::nf_deallocate
    #[inline(always)]
    pub(super) fn get_actual_prev(&self) -> Value {
        self.prev
    }
}

impl Iterator for NfIter<'_> {
    type Item = NfIterVal; // (prev, cur)
    fn next(&mut self) -> Option<Self::Item> {
        let cur = self.prev;
        let next = *get_next(&cur);

        if self.prev == self.get_globals().nf_prev && self.visited_start_once {
            None
        } else {
            self.visited_start_once = true;
            if next == VAL_NULL {
                self.get_globals_mut().nf_last = cur;
                self.prev = self.get_globals().nf_head;
                return self.next();
            }

            #[cfg(feature = "check_invariants")]
            assert_eq!(
                next.get_header().get_color(),
                BLUE,
                "FreeList entry pointing to a non free list value. Invariant failed",
            );
            self.prev = next;
            Some(Self::Item {
                prev: cur,
                cur: next,
                prev_is_sentinel: cur == self.get_globals().nf_head,
            })
        }
    }
}
